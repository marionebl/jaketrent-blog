<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: react | Jake Trent]]></title>
  <link href="http://jaketrent.com/blog/categories/react/atom.xml" rel="self"/>
  <link href="http://jaketrent.com/"/>
  <updated>2014-11-28T10:47:31-07:00</updated>
  <id>http://jaketrent.com/</id>
  <author>
    <name><![CDATA[Jake Trent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Send Props to Children in React]]></title>
    <link href="http://jaketrent.com/post/send-props-to-children-react/"/>
    <updated>2014-08-12T16:55:00-06:00</updated>
    <id>http://jaketrent.com/post/send-props-to-children-react</id>
    <content type="html"><![CDATA[<p>In React, you're always making components.  Sometimes components are standalone.  Other times, you'll have components that can nest children components.  Sometimes you'll want to send properties to the children components from the parent as often as a doting parent wants to send packages to a child missionary.  It's possible, it's simple, and it's not documented super well.  Here's one method.</p>

<p><img src="http://i.imgur.com/DXuSNbw.png" alt="React" /></p>

<!--more-->


<h2>Children Components</h2>

<p>When parent components are rendered, they have access to a special property, <code>this.props.children</code>.  It's like an Angular <code>ng-transclude</code> or an Ember <code>yield</code>.  Children components are generally rendered something like this:</p>

<p>```js
React.createClass({
  render: function () {</p>

<pre><code>return (
  &lt;div id="iAmParentHearMeRoar"&gt;
    {this.props.children}
  &lt;/div&gt;
)
</code></pre>

<p>  }
})
```</p>

<p>The generic example above shows simply how to render children, <code>props</code> untouched, within a parent component.  Sometimes, however, a parent wants to bequeath its children with extra properties.  How will we make that happen?</p>

<h2>Setting Child Props</h2>

<p><code>props</code> are meant to be immutable.  But, in order for us to send <code>props</code> values to our children, we're going to essentially loop through our children and set props on them as a part of our parent <code>render</code> function.</p>

<p>Deep breath.  It's ok.  The children that we'll loop through aren't mounted component instances.  They are, instead, <a href="http://facebook.github.io/react/blog/2014/07/17/react-v0.11.html#descriptors">descriptors</a>.  These descriptors have all the <code>props</code> attributes that we've declared should be put on the components, but they haven't been rendered yet.  Because of this, we can change props, and it's ok.  We're not mutating what has rendered.  The data still hasn't flowed to the children.  We're still effectively still riffing on the logic of what the children components should really be when they're eventually mounted.</p>

<h2>Looping on Children Components</h2>

<p><code>this.props.children</code> is a funny property.  It's special in more ways than one.  The things that might trip us up in looping is that even though it sounds like a plural thing, meaning an array, sometimes it's a singular object.  To help avoid potential problems, React gives us a helper, <code>React.Children</code>.  It has a few functions for array iteration, such as <code>map</code> and <code>forEach</code> that help account for the potential forms of <code>this.props.children</code>.</p>

<h2>Functional Modifications</h2>

<p>Immutable data is a big part of functional programming.  This means that when we 'mutate' the props, we want to mutate on a clone of the child component without affecting the original.  There's an input, there's an output, and the input is untouched.  Once we have our cloned children components as we want them, we'll render those instead.  React offers another great helper for cloning components and setting properties in a single function, <code>React.addons.cloneWithProps</code>.  Note that in order to use this function, you need to <code>require('react/addons')</code>.</p>

<h2>Checking Child Type</h2>

<p>It's a generally-useful thing to be able to tell what the React class type of a component object is.  It's an applicable skill in terms of looping through child components because we might not want to modify the properties of all types of children.  Each React component class has a <code>type</code> attribute accessible via <code>MyComponent.type</code>.  This attribute is also available on component descriptors.</p>

<h2>A Child CheckOption Example</h2>

<p>To bring this all together and illustrate the concepts, let's say we created a <code>RadioGroup</code> component that could take one or many <code>RadioOption</code> child components.  In raw html, which is what our component will eventually render, <code>input</code>s with type <code>checkbox</code> need to all have the same <code>name</code> attribute value to work well as toggles within the group.  But this is something that React can help us not have to duplicate.  We'll instead put a <code>name</code> property on the parent <code>RadioGroup</code> and have it transfer it as a property on all its children.  The implementation might look like this:</p>

<p>```js
/<em>* @jsx React.DOM </em>/</p>

<p>var React = require('react/addons')</p>

<p>var RadioOption = React.createClass({
  render: function () {</p>

<pre><code>return (
  &lt;label&gt;
    &lt;input type="radio" value={this.props.value} name={this.props.name} /&gt;
    {this.props.label}
  &lt;/label&gt;
)
</code></pre>

<p>  }
})</p>

<p>var RadioGroup = React.createClass({
  renderChildren: function () {</p>

<pre><code>return React.Children.map(this.props.children, function (child) {
  if (child.type === RadioOption.type)
    return React.addons.cloneWithProps(child, {
      name: this.props.name
    })
  else
    return child
}.bind(this))
</code></pre>

<p>  },
  render: function () {</p>

<pre><code>return (
  &lt;div class="radio-group"&gt;
    {this.renderChildren()}
  &lt;/div&gt;
)
</code></pre>

<p>  }
})</p>

<p>var WhereImUsingRadioGroups = React.createClass({
  render: function () {</p>

<pre><code>return (
  &lt;RadioGroup name="blizzard-games"&gt;
    &lt;RadioOption label="Warcraft 2" value="wc2" /&gt;
    &lt;RadioOption label="Warcraft 3" value="wc3" /&gt;
    &lt;RadioOption label="Starcraft 1" value="sc1" /&gt;
    &lt;RadioOption label="Starcraft 2" value="sc2" /&gt;
  &lt;/RadioGroup&gt;
)
</code></pre>

<p>  }
})
```</p>

<p>In this example, where the parent <code>RadioGroup</code> has the <code>name</code> prop, it will be given to each of the children so their <code>name</code> prop will match and the radio group will work as expected.  Thus, the hearts of the children are turned toward their fathers.</p>

<p>Is there a better way to do this?  How have you been sending <code>props</code> to children?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Set State in Callbacks in React]]></title>
    <link href="http://jaketrent.com/post/set-state-in-callbacks-in-react/"/>
    <updated>2014-06-23T08:30:00-06:00</updated>
    <id>http://jaketrent.com/post/set-state-in-callbacks-in-react</id>
    <content type="html"><![CDATA[<p>In React, you can setup components that fetch their own data and set their own state with that data.  Because of the async nature of data fetching, you’ll have to make sure to keep things cleaned up to avoid the error of trying to set state in an unmounted component.</p>

<p><img src="http://i.imgur.com/DXuSNbw.png" alt="React" /></p>

<!--more-->


<h2>React Components setState</h2>

<p>If a React component fetches its own data, it will usually do so in the <code>componentDidMount</code> method.  In the data request callback, it will set its own state via the <code>this.setState</code> method.  (<code>this.state</code> should be treated as immutable.)  State should only be set on mounted components, or those components that are inserted into the dom.</p>

<p>If you attempt to set state on an unmounted component, you'll get an error that looks like this:</p>

<p><code>
Uncaught Error: Invariant Violation: replaceState(...): Can only update a mounted or mounting component.
</code></p>

<p>Others have reported this variation:</p>

<p><code>
Invariant Violation: replaceState(...): Cannot update while unmounting component. This usually means you called setState() on an unmounted component.
</code></p>

<p>Both indicate that you're setting state on a component that is not mounted.  How should one avoid this?  In my case, <code>setState</code> was being called in a callback that was firing after the component that initially started the request had already been unmounted from the dom.  Here are the two ways I addressed the problem...</p>

<h2>Assure Component isMounted</h2>

<p>If the component is mounted, <code>setState</code> is a safe bet.  If it's not mounted, never do it.  If it's not mounted, you probably don't about the state at that point either.  So wrap your state setting in <code>this.isMounted()</code>:</p>

<p>```js
React.createClass({
  componentDidMount: function () {</p>

<pre><code>MyModel.find(function (err, data) {
  if (this.isMounted()) {
    this.setState({ 
      goodiesFrom: data 
    })
  }
}.bind(this))
</code></pre>

<p>  }
  // ...
})
```</p>

<p>It feels a bit like a hack, but it makes the code safe.  Another option...</p>

<h2>Abort the Request</h2>

<p>My asynchronous action is a network request that, when finished, will call the callback function.  When the component unmounts, I can just throw away the request so the callback is never invoked.  To do this, we'll take advantage of another React lifecycle hook, <code>componentWillUnmount</code>:</p>

<p>```js my-component.js
React.createClass({
  componentDidMount: function () {</p>

<pre><code>this.req = MyModel.find(function (err, data) {
  this.setState({})
}.bind(this))
</code></pre>

<p>  },
  componentWillUnmount: function () {</p>

<pre><code>this.req.abort()
</code></pre>

<p>  }
  // ...
})
```</p>

<p>In my model, I'm using the <a href="https://github.com/visionmedia/superagent">superagent</a> library for network requests which provides an <a href="http://visionmedia.github.io/superagent/#aborting-requests">abort</a> method.</p>

<p>```js my-model.js
var request = require(‘superagent')
MyModel.prototype.find = function (done) {
  return request(‘modelUrl’)</p>

<pre><code>.end(function (err, data) {
  if (data) {
    done(err, data.body)
  }
})
</code></pre>

<p>}
```</p>

<p>Also note that in my <code>end</code> function callback, I'm checking for the existence of data.  This is because when a request is aborted, data will come back as undefined.</p>

<p>My favored method for solving the problem is the latter request abort method.  It feels cleaner that we're relying on the lifecycle functions of the component to deal with cleanup, much like we would for <a href="http://facebook.github.io/react/tips/dom-event-listeners.html">events</a>.  How have you dealt with this problem?</p>
]]></content>
  </entry>
  
</feed>
